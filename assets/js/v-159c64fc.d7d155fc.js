"use strict";(self.webpackChunkvuepress_docs=self.webpackChunkvuepress_docs||[]).push([[941],{9300:(e,o,t)=>{t.r(o),t.d(o,{data:()=>a});const a={key:"v-159c64fc",path:"/topics/django/",title:"About the Django Application",lang:"en-US",frontmatter:{next:"/topics/quasar",prev:"/topics/twelve-factor-app"},excerpt:"",headers:[{level:2,title:"Data Model",slug:"data-model",children:[{level:3,title:"Core App",slug:"core-app",children:[]},{level:3,title:"Blog App",slug:"blog-app",children:[]}]},{level:2,title:"Views",slug:"views",children:[]},{level:2,title:"Custom User Model",slug:"custom-user-model",children:[]},{level:2,title:"Poetry for managing Django project dependencies",slug:"poetry-for-managing-django-project-dependencies",children:[]},{level:2,title:"GraphQL with Graphene",slug:"graphql-with-graphene",children:[]},{level:2,title:"Django REST Framework",slug:"django-rest-framework",children:[{level:3,title:"Function based views",slug:"function-based-views",children:[]},{level:3,title:"ModelViewSet",slug:"modelviewset",children:[]},{level:3,title:"@action decorator",slug:"action-decorator",children:[]},{level:3,title:"get_queryset method",slug:"get-queryset-method",children:[]}]},{level:2,title:"OpenAPI Documentation",slug:"openapi-documentation",children:[]},{level:2,title:"JWT Authentication and HttpOnly Cookies",slug:"jwt-authentication-and-httponly-cookies",children:[]}],filePathRelative:"topics/django/README.md",git:{updatedTime:1664141954e3,contributors:[]}}},603:(e,o,t)=>{t.r(o),t.d(o,{default:()=>h});var a=t(6252);const i=(0,a.uE)('<h1 id="about-the-django-application" tabindex="-1"><a class="header-anchor" href="#about-the-django-application" aria-hidden="true">#</a> About the Django Application</h1><p>The Django application is the main component of the backend and handles the following:</p><ul><li>Return responses for web requests (using gunicorn)</li><li>Process asynchronous tasks (using Celery)</li></ul><h2 id="data-model" tabindex="-1"><a class="header-anchor" href="#data-model" aria-hidden="true">#</a> Data Model</h2><p>The Django project is a simple blogging application. The main data model is a <code>Post</code> model that contains a few different types of fields:</p><ul><li><code>body</code>: The title of the post, a <code>CharField</code></li><li><code>image</code>: An optional image associated with the post, an <code>ImageField</code></li><li><code>likes</code>: ManyToMany field to <code>PostLike</code> model (through model)</li><li><code>created_on</code>: <code>DateTimeField</code> (inherited from <code>BaseModel</code>)</li><li><code>modified_on</code>: <code>DateTimeField</code> (inherited from <code>BaseModel</code>)</li><li><code>created_by</code>: <code>ForeignKey</code> to <code>CustomUser</code> model (inherited from <code>BaseModel</code>)</li></ul><h3 id="core-app" tabindex="-1"><a class="header-anchor" href="#core-app" aria-hidden="true">#</a> Core App</h3><ul><li>RequestLog</li></ul><h3 id="blog-app" tabindex="-1"><a class="header-anchor" href="#blog-app" aria-hidden="true">#</a> Blog App</h3><ul><li>Blog Post</li><li>Like</li></ul><h2 id="views" tabindex="-1"><a class="header-anchor" href="#views" aria-hidden="true">#</a> Views</h2><p>Views are where most of the work of the request/response cycle takes place. In Django, views are functions or classes responsible for handling requests and returning responses.</p><p>This application uses several different types of views:</p><ul><li>function-based views</li><li>class-based views</li></ul><p>The function based views are fairly easy to read and understand and are find for most use cases. Class-based views can be used to achieve the same functionality as function-based views but require less code. Customizing the behavior of class-based views requires overwriting methods of view class being used.</p><h2 id="custom-user-model" tabindex="-1"><a class="header-anchor" href="#custom-user-model" aria-hidden="true">#</a> Custom User Model</h2><p>Django has a default model that provides a user model. Instead of using this, we can subclass the <code>AbstractBaseUser</code> model to keep most of the same behavior, but also have a more flexible model that will allow us to add custom fields.</p>',17),s=(0,a.Uk)("See "),n={href:"https://docs.djangoproject.com/en/3.2/topics/auth/customizing/",target:"_blank",rel:"noopener noreferrer"},d=(0,a.Uk)("Customizing authentication in Django"),r=(0,a.Uk)(" for more information on customizing authentication in Django."),c=(0,a.uE)('<h2 id="poetry-for-managing-django-project-dependencies" tabindex="-1"><a class="header-anchor" href="#poetry-for-managing-django-project-dependencies" aria-hidden="true">#</a> Poetry for managing Django project dependencies</h2><p>Poetry is used as a dependency manager for Django projects. First we can have a look at how poetry works at a high level. We can list all of the project&#39;s python dependencies in <code>pyproject.toml</code>, including development dependencies (such as <code>pytest</code> for example) and product-only dependencies (such as the <code>Django</code> package). This <code>pyproject.toml</code> file is then used to create a <code>poetry.lock</code> file that contains the exact version of each dependency.</p><h2 id="graphql-with-graphene" tabindex="-1"><a class="header-anchor" href="#graphql-with-graphene" aria-hidden="true">#</a> GraphQL with Graphene</h2><h2 id="django-rest-framework" tabindex="-1"><a class="header-anchor" href="#django-rest-framework" aria-hidden="true">#</a> Django REST Framework</h2><p>Django REST Framework (DRF) is used to build the REST API for Î¼blog. The REST API is implemented in two different ways:</p><ul><li>using function-based views</li><li>using class-based views</li></ul><h3 id="function-based-views" tabindex="-1"><a class="header-anchor" href="#function-based-views" aria-hidden="true">#</a> Function based views</h3><p>Django REST Framework allows you to use functions to handle API requests. The functions must be decorated with the <code>@api_view</code> decorator, and other decorators can be used to customize view behavior. One function is used per CRUD operation on our blog post model. There is also a function used to handle requests made when an authenticated user clicks the <code>like</code> button.</p><h3 id="modelviewset" tabindex="-1"><a class="header-anchor" href="#modelviewset" aria-hidden="true">#</a> ModelViewSet</h3><p>Similar to Django, DRF allows you to express views with both functions and classes. There are multiple approaches that can be used with class-based. <code>ModelViewSet</code> is used in this sample application. The <code>ModelViewSet</code> class is used to create a view that can be used to create, retrieve, update, and delete a model instance.</p><h3 id="action-decorator" tabindex="-1"><a class="header-anchor" href="#action-decorator" aria-hidden="true">#</a> <code>@action</code> decorator</h3><p>For the like button functionality, the <code>@action</code> decorator is used to create a custom action on blog posts.</p><h3 id="get-queryset-method" tabindex="-1"><a class="header-anchor" href="#get-queryset-method" aria-hidden="true">#</a> <code>get_queryset</code> method</h3><p>The <code>get_queryset</code> method is used to efficiently fetch the number of likes for each blog post, and to a boolean property that indicates that the current user (if there is one) has liked a given post.</p><h2 id="openapi-documentation" tabindex="-1"><a class="header-anchor" href="#openapi-documentation" aria-hidden="true">#</a> OpenAPI Documentation</h2><p>OpenAPI is used to build documentation for the API built with Django REST Framework.</p><h2 id="jwt-authentication-and-httponly-cookies" tabindex="-1"><a class="header-anchor" href="#jwt-authentication-and-httponly-cookies" aria-hidden="true">#</a> JWT Authentication and HttpOnly Cookies</h2><p>How to do authentication in Django REST Framework project is sometimes a heated debate over web standards and security best practices. This project implements one of the most popular packages for authentication in Django REST Framework, <code>djangorestframework-simplejwt</code> with some modifications.</p><p>The modifications involve sub-classing certain classes used for authentication so that the <code>refresh_token</code> can be stored in an <code>HttpOnly</code> cookie. This behavior is not provided by default, but it is important to do this so that credentials do not need to be stored in the browser&#39;s <code>localStorage</code> or in cookies that can be accessed by JavaScript.</p><p>The access token is retrieved from the body of an authentication endpoint (where the username and password are supplied) and is then attached to each request that the browser makes to the API (using axios). The access token is stored in memory in a Vue.js <code>ref</code> object. The access token is used to authenticate requests on the server without having to make extra database queries.</p><p>The payload of the JWT access token is not used to retrieve any information. Instead, a separate authenticated request is made to fetch information on the user (user profile information).</p><p>When the user authenticates with a username and password and gets the <code>access</code> token as described above, there is no <code>refresh</code> token in the response body. Instead, the <code>refresh</code> token is set in an <code>HttpOnly</code> cookie on the server that is then set on the web browser client. The refresh cookie is used to refresh the short-lived <code>access</code> token.</p><p>See <code>auth_views.py</code> for the code that customizes the <code>djangorestframework-simplejwt</code> package behavior.</p>',23),h={render:function(e,o){const t=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.j4)(a.HY,null,[i,(0,a.Wm)("p",null,[s,(0,a.Wm)("a",n,[d,(0,a.Wm)(t)]),r]),c],64)}}}}]);